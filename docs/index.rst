The JiTCODE module
==================

Overview
--------

JiTCODE (just-in-time compilation for ordinary differential equations) is an extension of `SciPy’s ODE`_ (`scipy.integrate.ode`).
Where SciPy’s ODE takes a Python function as an argument, JiTCODE takes a list of `SymPy <http://www.sympy.org/>`_ terms, which are then translated to C code, compiled on the fly, and used as the function to feed into SciPy’s ODE.
This has the following advantages:

*	**Speed boost through compilation**
	There are two main computational burdens when numerically solving ODEs.
	The first is adding vectors for the integration procedure, which can be efficiently handled by NumPy.
	The second is calculating the derivative (and Jacobian), which can be efficiently handled with just-in-time compilation.
	Note that for smaller ODEs and small integration times, the Python overhead may still take a considerable toll in comparison to pure compiled code.
  
*	**Speed boost through symbolic optimisation**
	If your derivative is automatically generated by some routine, you can simplify it symbolically to boost the speed.
	In fact, blatant optimisations such as :math:`y·(x-x)=0` are done on the fly by SymPy.
	This is for example interesting if you want to simulate dynamics on a sparse network, as non-existing links are not taken into account when calculating the derivative when integrating.

*	**Automatically calculated Jacobian and Lyapunov exponents**
	As the derivative is provided symbolically, SymPy’s automatic derivation routines can be employed to calculate the Jacobian desired by some integrators as well as the ODE for the tangent vector required for calculating the Lyapunov expontents (see `lyapunov`).

*	**SymPy interface**
	If you are working with SymPy anyway – e.g., to calculate fixed points –, you do not need to bother much with translating your equations.

If compilation fails to work for whatever reason, pure Python functions can be employed as a fallback.

For most applications, the only difference to SciPy’s ODE in terms of handling is that you have to supply the derivative in the correct format – JiTCODE automatically takes care of the compilation.
However, you can also tweak this step by step, if you desire (see `tweak`).

This documentation assumes that you have read the documentation of `SciPy’s ODE`_ or are otherwise familiar with it.
As with SciPy’s ODE, this documentation assumes that the differential equation you want to solve is:

.. math::

	\dot{y} = f(y)

.. _example:

A quick example
---------------

.. automodule:: double_fhn_example

.. literalinclude:: ../examples/double_fhn_example.py
	:linenos:
	:dedent: 1
	:start-after: example-start

.. _tweak:

Details of the building process
-------------------------------

To generate the functions needed by SciPy’s ODE, JiTCODE executes a series of distinct processing steps, each of which can be invoked through a command and tweaked as needed.
These commands execute previous steps as needed, i.e., if they have not been performed yet.
If you are happy with the default options, however, you do not need to bother with this and can just use the commands at the very end of the chain, namely `set_integrator`, `set_initial_value`, or `save_compiled`.

The following diagram details which command calls which other command when needed:

.. digraph:: foo
	
	node [shape=box fontname="Monospace"];
	{rank = same; "save_compiled"; "set_integrator"}
	"set_initial_value" -> "set_integrator";
	"save_compiled" -> "compile_C";
	"set_integrator" -> "generate_functions" -> "compile_C" -> "generate_f_C";
	"compile_C" -> "generate_jac_C" -> "generate_jac_sym";
	"generate_functions" -> "generate_lambdas" -> "generate_f_lambda";
	"generate_lambdas" -> "generate_jac_lambda"-> "generate_jac_sym";

.. _lyapunov:

Calculating Lyapunov exponents with `jitcode_lyap`
--------------------------------------------------

`jitcode_lyap` is a simple extension of `jitcode` that almost automatically handles calculating Lyapunov exponents by evolving tangent vectors [BGGS80]_.
It works just like `jitcode`, except that it generates and integrates additional differential equations for the tangent vectors.
After every call of `integrate`, the tangent vectors are orthonormalised, and the “local” Lyapunov exponents for this integration step are returned alongside with the system’s state.
These can then be further processed to obtain the Lyapunov exponents.
The tangent vectors are intialised with random vectors, and you have to take care of the preiterations that the tangent vectors require to align themselves.

.. automodule:: double_fhn_lyapunov

.. literalinclude:: ../examples/double_fhn_lyapunov.py
	:emphasize-lines: 22-23,29-32
	:start-after: example-start
	:dedent: 1
	:linenos:3

What doesn’t work (yet)
-----------------------

The following features of SciPy’s ODE class cannot be used through JiTCODE:

*	The `zvode` integrator and complex arithmetics in general, as they are not easy implementable in C.

*	Passing parameters to the derivative at integration time (via `set_f_params` or `set_jac_params`).
	I figured that there shouldn’t be much need for this, as it may render the whole purpose of just-in-time compilation moot in most cases.

.. _reference:

A more complicated example
--------------------------

.. automodule:: SW_of_Roesslers


Command reference
-----------------

.. automodule:: _jitcode
	:members:


References
----------

.. [BGGS80]  G. Benettin, L. Galgani, A. Giorgilli, and J.-M. Strelcyn: Lyapunov Characteristic Exponents for smooth dynamical systems and for Hamiltonian systems; A method for computing all of them. Meccanica 15, pp. 9–30 (1980), `10.1007/BF02128236 <http://dx.doi.org/10.1007/BF02128236>`_.

.. _SciPy’s ODE: http://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.ode.html

.. _SymPy Issue 8997: https://github.com/sympy/sympy/issues/8997
