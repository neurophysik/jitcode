The JiTCODE module
==================

Overview
--------

JiTCODE (just-in-time compilation for ordinary differential equations) is an extension of `SciPy’s ODE`_ (`scipy.integrate.ode`).
Where SciPy’s ODE takes a Python function as an argument, JiTCODE takes an iterable (or generator function) of `SymPy <http://www.sympy.org/>`_ expressions, which it translates to C code, compiles on the fly, and uses as the function to feed into SciPy’s ODE.
This has the following advantages:

*	**Speed boost through compilation**
	There are two main computational burdens when numerically solving ODEs.
	The first is adding vectors for the integration procedure, which can be efficiently handled by NumPy.
	The second is calculating the derivative (and Jacobian), which can be efficiently handled with just-in-time compilation.
	Note that for smaller ODEs and small integration times, the Python overhead may still take a considerable toll in comparison to pure compiled code.
  
*	**Speed boost through symbolic optimisation**
	If your derivative is automatically generated by some routine, you can simplify it symbolically to boost the speed.
	In fact, blatant optimisations such as :math:`y·(x-x)=0` are done on the fly by SymPy.
	This is for example interesting if you want to simulate dynamics on a sparse network, as non-existing links are not taken into account when calculating the derivative when integrating.

*	**Automatically calculated Jacobian and Lyapunov exponents**
	As the derivative is provided symbolically, SymPy’s automatic derivation routines can be employed to calculate the Jacobian desired by some integrators as well as the ODE for the tangent vector required for calculating the Lyapunov expontents (see `lyapunov`).

*	**SymPy interface**
	If you are working with SymPy anyway – e.g., to calculate fixed points –, you do not need to bother much with translating your equations.

If compilation fails to work for whatever reason, pure Python functions can be employed as a fallback.

For most applications, the only difference to SciPy’s ODE in terms of handling is that you have to supply the derivative in the correct format – JiTCODE automatically takes care of the compilation.
However, you can also tweak this step by step, if you desire (see `tweak`).

This documentation assumes that you have read the documentation of `SciPy’s ODE`_ or are otherwise familiar with it.
As with SciPy’s ODE, this documentation assumes that the differential equation you want to solve is:

.. math::

	\dot{y} = f(y)



.. _example:

A quick example
---------------

.. automodule:: double_fhn_example

.. literalinclude:: ../examples/double_fhn_example.py
	:linenos:
	:dedent: 1
	:start-after: example-start



.. _tweak:

Details of the building process
-------------------------------

To generate the functions needed by SciPy’s ODE, JiTCODE executes a series of distinct processing steps, each of which can be invoked through a command and tweaked as needed.
These commands execute previous steps as needed, i.e., if they have not been performed yet.
If you are happy with the default options, however, you do not need to bother with this and can just use the commands at the very end of the chain, namely `set_integrator`, `set_initial_value`, or `save_compiled`.

The following diagram details which command calls which other command when needed:

.. digraph:: foo
	
	node [shape=box fontname="Monospace"];
	{rank = same; "save_compiled"; "set_integrator"}
	"set_initial_value" -> "set_integrator";
	"save_compiled" -> "compile_C";
	"set_integrator" -> "generate_functions" -> "compile_C" -> "generate_f_C" -> "generate_helpers_C";
	"compile_C" -> "generate_jac_C" -> "generate_jac_sym";
	"generate_jac_C"  -> "generate_helpers_C";
	"generate_functions" -> "generate_lambdas" -> "generate_f_lambda";
	"generate_lambdas" -> "generate_jac_lambda"-> "generate_jac_sym";



.. _large_systems:

Handling very large differential equations
------------------------------------------

For very large differential equations, there are two sources of memory or speed problems:

* **The compiler**, who has to compile megabytes of unstructured code and tries to handle it all at once, which may use too much time and memory. For some compilers, disabling all optimisation can avert this problem, but then, compiler optimisations usually are a good thing.

  As a compromise, JiTCODE structures large source code into chunks, which the compiler then handles separately. This way optimisation can happen within the chunks, but not accross chunks. The precise size of those chunks can be controlled by the option `chunk_size` which is available for all code-generation subroutines.
  
  We obtained better performances in these regards with Clang than with GCC.

* **SymPy’s cache**, which may use too much memory. While it can be completely deactivated by setting the environment variable `SYMPY_USE_CACHE=no`, it exists for a reason and may speed things up.

  To address this, JiTCODE clears the cache after each chunk is written and accepts generator functions as an input for :math:`f`, which makes SymPy’s handling of an entry happen right before the corresponding code is generated. See `example_2` for an example how to use a generator function.



.. _example_2:

A more complicated example
--------------------------

.. automodule:: SW_of_Roesslers



.. _lyapunov:

Calculating Lyapunov exponents with `jitcode_lyap`
--------------------------------------------------

`jitcode_lyap` is a simple extension of `jitcode` that almost automatically handles calculating Lyapunov exponents by evolving tangent vectors [BGGS80]_.
It works just like `jitcode`, except that it generates and integrates additional differential equations for the tangent vectors.
After every call of `integrate`, the tangent vectors are orthonormalised, and the “local” Lyapunov exponents for this integration step are returned alongside with the system’s state.
These can then be further processed to obtain the Lyapunov exponents.
The tangent vectors are intialised with random vectors, and you have to take care of the preiterations that the tangent vectors require to align themselves.

Estimates for the Lyapunov vectors are returned as well.

.. automodule:: double_fhn_lyapunov

.. literalinclude:: ../examples/double_fhn_lyapunov.py
	:emphasize-lines: 22-23,28-38
	:start-after: example-start
	:dedent: 1
	:linenos:



Command reference
-----------------

.. automodule:: _jitcode
	:members:



What doesn’t work (yet)
-----------------------

The following features of SciPy’s ODE class cannot be used through JiTCODE:

*	The `zvode` integrator and complex arithmetics in general, as they are not easy implementable in C.

*	Passing parameters to the derivative at integration time (via `set_f_params` or `set_jac_params`).
	I figured that there shouldn’t be much need for this, as it may render the whole purpose of just-in-time compilation moot in most cases.



.. _reference:

References
----------

.. [BGGS80]  G. Benettin, L. Galgani, A. Giorgilli, and J.-M. Strelcyn: Lyapunov Characteristic Exponents for smooth dynamical systems and for Hamiltonian systems; A method for computing all of them. Meccanica 15, pp. 9–30 (1980), `10.1007/BF02128236 <http://dx.doi.org/10.1007/BF02128236>`_.

.. _SciPy’s ODE: http://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.ode.html

.. _SymPy Issue 4596: https://github.com/sympy/sympy/issues/4596

.. _SymPy Issue 8997: https://github.com/sympy/sympy/issues/8997


